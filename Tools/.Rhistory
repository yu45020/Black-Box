if (remove_first_dummy) {
unique_vals = unique_vals[-1]
}
if (col_name %in% conditional_columns) {
conditional_names <- c(conditional_names, paste0(col_name,
"_", unique_vals))
}
else {
nonconditional_names <- c(nonconditional_names,
paste0(col_name, "_", unique_vals))
}
dataset[, `:=`((paste0(col_name, "_", unique_vals)),
0)]
for (unique_values in unique_vals) {
dataset[get(col_name) == unique_values, `:=`((paste0(col_name,
"_", unique_values)), 1)]
}
}
nonconditional_names <- nonconditional_names[-1]
conditional_names <- conditional_names[-1]
if (remove_original) {
dataset[, `:=`((char_cols), NULL)]
}
if (!is.null(conditional_columns)) {
for (conditional_cols in conditional_names) {
for (nonconditional_columns in nonconditional_names) {
dataset[, `:=`(paste0(conditional_cols, "X",
nonconditional_columns), (get(conditional_cols) *
get(nonconditional_columns)))]
}
}
}
if (return_type == "data.table") {
return(dataset)
}
else if (return_type == "data.frame") {
return(as.data.frame(dataset))
}
else if (return_type == "matrix") {
return(as.matrix(dataset))
}
}
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
warnings()
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
setwd("D:/ProgramData/Black-Box/Tools")
DT = get_test_data(N=1e3,K=10)
###################################
# Helper Function ####
.create_col_names = function(unique_level,col_to_encode,drop_first_level,sep_char){
if(drop_first_level){
unique_level = lapply(unique_level,FUN=function(x)x[-1])
}
col_names= mapply(paste, col_to_encode, unique_level,sep=sep_char,SIMPLIFY = FALSE)
return(col_names)
}
.create_dummy_cols = function(col){
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
dat[,(col_name):=lapply(col_unique, chmatch, x=get(col),nomatch=0L)]
}
.create_dummy_cols_parallel = function(col){
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
lapply(col_unique,chmatch,dat[,..col],nomatch=0L)
}
###################################
# Helper Function ####
.create_col_names = function(unique_level,col_to_encode,drop_first_level,sep_char){
if(drop_first_level){
unique_level = lapply(unique_level,FUN=function(x)x[-1])
}
col_names= mapply(paste, col_to_encode, unique_level,sep=sep_char,SIMPLIFY = FALSE)
return(col_names)
}
###################################
# Helper Function ####
.create_col_names = function(unique_level,col_to_encode,drop_first_level,sep_char){
if(drop_first_level){
unique_level = lapply(unique_level,FUN=function(x)x[-1])
}
col_names= mapply(paste, col_to_encode, unique_level,sep=sep_char,SIMPLIFY = FALSE)
return(col_names)
}
.create_dummy_cols = function(col){
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
dat[,(col_name):=lapply(col_unique, chmatch, x=get(col),nomatch=0L)]
}
.create_dummy_cols_parallel = function(col){
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
lapply(col_unique,chmatch,dat[,..col],nomatch=0L)
}
###################################
drop_first_level=FALSE,
drop_first_level=FALSE
sep_char='='
# get non-numeric column names
col_attr = sapply(dat, is.numeric)
col_to_encode = c(names(dat)[!col_attr])
dat[,(col_to_encode):=lapply(.SD,as.character),.SDcols=col_to_encode]
dat=DT
# get non-numeric column names
col_attr = sapply(dat, is.numeric)
col_to_encode = c(names(dat)[!col_attr])
dat[,(col_to_encode):=lapply(.SD,as.character),.SDcols=col_to_encode]
# get unique values for each columns
unique_level_percol = dat[,.(lapply(.SD,unique)),.SDcols=col_to_encode]$V1
names(unique_level_percol)= col_to_encode
unique_level_percol = lapply(unique_level_percol,as.character) # make sure no factor
# get newe column names with unique value e.g. col1=type A
col_newname = .create_col_names(unique_level_percol,col_to_encode,drop_first_level,sep_char)
col
names(dat)
col_='id1'
col_unique = unique_level_percol[[col]]
unique_level_percol
col
col='id1'
col
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
col_unique
col_name
lapply(col_unique,chmatch,dat[,..col],nomatch=0L)
dat$id1
col
col_name
lapply(col_unique,chmatch,dat[,..col],nomatch=0L)
sapply(col_unique,chmatch,dat[,..col],nomatch=0L)
dat[,..col]
dat[,..col]$id3
dat$col
dat[,c(col)]
dat[,.(col)]
dat[,col,with=FALSE]
dat[,col,with=FALSE]$id1
dat[,.SD,.SDcols=col]
lapply(col_unique,chmatch,dat[,.SD,.SDcols=col],nomatch=0L)
a=dat[,.SD,.SDcols=col]
a[,]
lapply(col_unique,chmatch,a,nomatch=0L)
lapply(col_unique,chmatch,a[,],nomatch=0L)
lapply(col_unique,chmatch,a$id1,nomatch=0L)
lapply(col_unique,chmatch,dat$id1,nomatch=0L)
col_unique
lapply(col_unique,chmatch,x=dat$id1,nomatch=0L)
lapply(col_unique,chmatch,x=dat$id1,nomatch=0L)    lapply(col_unique,chmatch,x=dat[,.SD,.SDcols=col],nomatch=0L)
a    lapply(col_unique,chmatch,x=dat[,.SD,.SDcols=col],nomatch=0L)
lapply(col_unique,chmatch,x=dat[,.SD,.SDcols=col],nomatch=0L)
lapply(col_unique,chmatch,x=dat[,.col],nomatch=0L)
lapply(col_unique,chmatch,x=dat[on=col],nomatch=0L)
lapply(col_unique,chmatch,x=dat[,on=col],nomatch=0L)
lapply(col_unique,chmatch,x=dat[,c(col)],nomatch=0L)
lapply(col_unique,chmatch,x=dat[,c(col)],nomatch=0L)
dat[,.(c(col))]
dat[,.col]
dat[,c(col),with=FALSE]
dat[,.(col),with=FALSE]
dat[,..(col),with=FALSE]
dat[,list(col),with=FALSE]
dat[,(col),with=FALSE]
dat[,c(col),with=FALSE]
subset(dat,select = col)
dat[col,with=FALSE]
dat[col,]
dat[col]
dat[,c(col)]
dat[,c(col),with=FALSE]
dat[,get(col)]
lapply(col_unique,chmatch,x=dat[,get(col)],nomatch=0L)
col_name
col_name
.create_dummy_cols_parallel = function(col){
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
dummy_cols = lapply(col_unique,chmatch,x=dat[,get(col)],nomatch=0L)
names(dummy_cols) = col_name
return(dummy_cols)
}
col_
#.create_dummy_cols(col)
.create_dummy_cols_parallel(col_)
?parlapp
ibrary(parallel())
library(parallel)
?parLapply
.parallel_init=function(){
no_cores = detectCores()
cl=makeCluster(no_cores)
clusterExport('data.table')
}
.parallel_init()
.parallel_init=function(){
no_cores = detectCores()
cl=makeCluster(no_cores)
clusterEvalQ(cl,library(data.table))
}
.parallel_init
.parallel_init()
no_cores = detectCores()
stopCluster(cl)
cl
stopCluster(cl)
stopCluster(cl)
no_cores = detectCores()
cl=makeCluster(no_cores)
clusterEvalQ(cl,library(data.table))
dat_2 = parLapply(cl,
col_to_encode,
function(x) .create_dummy_cols_parallel(col_)
)
.create_dummy_cols_parallel = function(col){
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
dummy_cols = lapply(col_unique,chmatch,x=dat[,get(col)],nomatch=0L)
names(dummy_cols) = col_name
return(dummy_cols)
}
dat_2 = parLapply(cl,
col_to_encode,
function(x) .create_dummy_cols_parallel(col_)
)
.create_dummy_cols_parallel
clusterExport(cl,.create_dummy_cols_parallel)
clusterExport(cl,".create_dummy_cols_parallel")
dat_2 = parLapply(cl,
col_to_encode,
function(x) .create_dummy_cols_parallel(col_)
)
clusterEvalQ(cl,".create_dummy_cols_parallel")
stopCluster(cl)
no_cores = detectCores()
cl=makeCluster(no_cores)
clusterEvalQ(cl,library(data.table))
clusterEvalQ(cl,".create_dummy_cols_parallel")
dat_2 = parLapply(cl,
col_to_encode,
function(x) .create_dummy_cols_parallel(col_)
)
clusterEvalQ(cl,.create_dummy_cols_parallel)
dat_2 = parLapply(cl,
col_to_encode,
function(x) .create_dummy_cols_parallel(col_)
)
stopCluster(cl)
stopCluster(cl)
col_
for(col_ in col_to_encode){
#.create_dummy_cols(col)
dat = .create_dummy_cols_parallel(col_)
}
DT
dat=copy(DT)
for(col_ in col_to_encode){
#.create_dummy_cols(col)
dat_ = .create_dummy_cols_parallel(col_)
}
dat_
a = rbind(dat_)
head(a)
a
a=rbindlist(dat_)
dat$id1
dat_$`id5=9`
a=Reduce(merge,dat,dat_)
a
?do.call
dat_ = do.call(.create_dummy_cols_parallel,list(col_to_encode))
dat_ = do.call(.create_dummy_cols_parallel,as.list(col_to_encode))
as.list(col_to_encode)
dat_ = do.call(.create_dummy_cols_parallel,col_to_encode)
dat_ = do.call(.create_dummy_cols_parallel,as.list(col_to_encode))
a = Reduce(merge,dat,dat_,all=TRUE,sort=FALSE)
?Reduce
dat_
merge_ = function(x,y){
return(merge(x,y,all=TRUE,sort=FALSE))
}
a = Reduce(merge_,dat,dat_)
View(a)
?cbind
a = Reduce(cbind,dat,dat_)
View(a)
.create_dummy_cols
dat= .create_dummy_cols(col)
dat
dat
rm(list=ls())
dummyencoder_1 = function(dat_, keep_col=FALSE, drop_first_level=FALSE, sep_char='=',inplace=FALSE,index_col){
########## Helper Function ################
.create_col_names = function(unique_level,col_to_encode,drop_first_level,sep_char){
if(drop_first_level){
unique_level = lapply(unique_level,FUN=function(x)x[-1])
}
col_names= mapply(paste, col_to_encode, unique_level,sep=sep_char,SIMPLIFY = FALSE)
return(col_names)
}
.index_data_when_match = function(){
for(col in col_to_encode){
col_name_dummy = col_newname[[col]]
unique_level = unique_level_percol[[col]]
for(i in 1:length(col_name_dummy)){
dat[unique_level[i],(col_name_dummy[i]):=1L, on=col]
}
}
return(dat)
}
.noindex_data_when_match = function(unique_level_,col_name_dummy_,col_){
for(col in col_to_encode){
col_name_dummy = col_newname[[col]]
unique_level = unique_level_percol[[col]]
for(i in 1:length(col_name_dummy)){
dat[get(col) == unique_level[i],(col_name_dummy[i]):=1L]
}
}
return(dat)
}
###################################
if(inplace){
dat = dat_
}else{
dat = copy(dat_)
}
# get non-numeric column names
col_attr = sapply(dat, is.numeric)
col_to_encode = c(names(dat)[!col_attr])
dat[,(col_to_encode):=lapply(.SD,as.character),.SDcols=col_to_encode]
# get unique values for each columns
unique_level_percol = dat[,.(lapply(.SD,unique)),.SDcols=col_to_encode]$V1
names(unique_level_percol)= col_to_encode
unique_level_percol = lapply(unique_level_percol,as.character) # make sure no factor
# get newe column names with unique value e.g. col1=type A
col_newname = .create_col_names(unique_level_percol,col_to_encode,drop_first_level,sep_char)
# create dummy columns with all 0
#dat[,(unlist(col_newname)):=0L]
#  for(col in col_to_encode){
#    col_unique = unique_level_percol[[col]]
#    col_name = col_newname[[col]]
#    dat[,(col_name):=lapply(as.list(col_unique), chmatch, x=get(col),nomatch=0)]
#  }
.create_dummy_cols = function(col){
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
dat[,(col_name):=lapply(col_unique, chmatch, x=get(col),nomatch=0L)]
}
# assign matched row entry to 1
if (index_col=="index"){
setindexv(dat, col_to_encode)
dat = .index_data_when_match()
}else if(index_col=='no'){
dat = .noindex_data_when_match()
}else if(index_col=='bypass'){
for(col in col_to_encode){
.create_dummy_cols(col)
}
}
return(dat)
}
dummyencoder_1
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
col_
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
dummyencoder_1(DT,index_col = 'no')
dummyencoder(DT)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
rm(list=ls())
gc()
dummyencoder_1 = function(dat_, keep_col=FALSE, drop_first_level=FALSE, sep_char='=',inplace=FALSE,index_col){
########## Helper Function ################
.create_col_names = function(unique_level,col_to_encode,drop_first_level,sep_char){
if(drop_first_level){
unique_level = lapply(unique_level,FUN=function(x)x[-1])
}
col_names= mapply(paste, col_to_encode, unique_level,sep=sep_char,SIMPLIFY = FALSE)
return(col_names)
}
.index_data_when_match = function(){
for(col in col_to_encode){
col_name_dummy = col_newname[[col]]
unique_level = unique_level_percol[[col]]
for(i in 1:length(col_name_dummy)){
dat[unique_level[i],(col_name_dummy[i]):=1L, on=col]
}
}
return(dat)
}
.noindex_data_when_match = function(unique_level_,col_name_dummy_,col_){
for(col in col_to_encode){
col_name_dummy = col_newname[[col]]
unique_level = unique_level_percol[[col]]
for(i in 1:length(col_name_dummy)){
dat[get(col) == unique_level[i],(col_name_dummy[i]):=1L]
}
}
return(dat)
}
###################################
if(inplace){
dat = dat_
}else{
dat = copy(dat_)
}
# get non-numeric column names
col_attr = sapply(dat, is.numeric)
col_to_encode = c(names(dat)[!col_attr])
dat[,(col_to_encode):=lapply(.SD,as.character),.SDcols=col_to_encode]
# get unique values for each columns
unique_level_percol = dat[,.(lapply(.SD,unique)),.SDcols=col_to_encode]$V1
names(unique_level_percol)= col_to_encode
unique_level_percol = lapply(unique_level_percol,as.character) # make sure no factor
# get newe column names with unique value e.g. col1=type A
col_newname = .create_col_names(unique_level_percol,col_to_encode,drop_first_level,sep_char)
# create dummy columns with all 0
#dat[,(unlist(col_newname)):=0L]
#  for(col in col_to_encode){
#    col_unique = unique_level_percol[[col]]
#    col_name = col_newname[[col]]
#    dat[,(col_name):=lapply(as.list(col_unique), chmatch, x=get(col),nomatch=0)]
#  }
.create_dummy_cols = function(col){
col_unique = unique_level_percol[[col]]
col_name = col_newname[[col]]
dat[,(col_name):=lapply(col_unique, chmatch, x=get(col),nomatch=0L)]
}
# assign matched row entry to 1
if (index_col=="index"){
setindexv(dat, col_to_encode)
dat = .index_data_when_match()
}else if(index_col=='no'){
dat = .noindex_data_when_match()
}else if(index_col=='bypass'){
for(col in col_to_encode){
.create_dummy_cols(col)
}
}
return(dat)
}
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
gc()
gc()
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
system.time(dummyencoder_1(DT,index_col = 'no'))
system.time(dummyencoder_1(DT,index_col = 'no'))
system.time(dummyencoder(DT))
system.time(dummyencoder(DT))
system.time(dummyencoder(DT))
system.time(dummyencoder(DT))
system.time(dummyencoder(DT))
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
# test ################
get_test_data=function(N=1e5,K=6){
set.seed(1)
DT <- data.table(
id1 = factor(sample(sprintf("id%03d",1:K), N, TRUE)),      # large groups (char)
id3 = sample(sprintf("id%010d",1:K), N, TRUE),     # small groups (char)
#id4 = sample(K, N, TRUE),                          # large groups (int)
id5 = factor(sample(K, N, TRUE)),                  # large groups (int)
#id6 = sample(N/K, N, TRUE),                        # small groups (int)
#v1 =  sample(5, N, TRUE),                          # int in range [1,5]
v3 =  sample(round(runif(100,max=100),4), N, TRUE) # numeric e.g. 23.5749
)
}
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
DT=get_test_data()
dat = encodedummy(DT)
dat
View(dat)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
rm(dat)
dat=encodedummy(DT)
a=c('c','b')
a[sort(a)]
sort(a)
sort(a)
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
dat=encodedummy(DT)
unique_level_percol
# get unique values for each columns
unique_level_percol = dat[,.(lapply(.SD,unique)),.SDcols=col_to_encode]$V1
col_to_encode
debugSource('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
unique_level_percol
sapply(unique_level_percol,sort)
lapply(unique_level_percol,sort)
rm(list=ls())
source('D:/ProgramData/Black-Box/Tools/encodedummy.R', echo=TRUE)
View(dat)
